---
alwaysApply: true
---
# Data Handling Patterns

## Overview
FlashyCardy follows strict server-side data patterns to ensure security, performance, and type safety. ALL data operations must follow these established patterns.

## Critical Requirements

### 1. Data Abstraction: db/queries Directory Required
ALL data operations MUST be abstracted into helper functions located in the `db/queries` directory. NO direct database operations should be performed in pages, components, or Server Actions:

```typescript
// ✅ CORRECT - Query helper functions in db/queries/deck-queries.ts
import { db } from "@/db";
import { decksTable, cardsTable, type NewDeck, type Deck } from "@/db/schema";
import { eq, and } from "drizzle-orm";

export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

export async function getDeckWithCards(deckId: string, userId: string) {
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)));
    
  if (!deck) return null;
  
  const cards = await db.select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId));
    
  return { ...deck, cards };
}

export async function createDeck(deckData: NewDeck) {
  const [newDeck] = await db.insert(decksTable)
    .values(deckData)
    .returning();
  return newDeck;
}

export async function updateDeck(deckId: string, updates: Partial<Deck>) {
  const [updatedDeck] = await db.update(decksTable)
    .set({ ...updates, updatedAt: new Date() })
    .where(eq(decksTable.id, deckId))
    .returning();
  return updatedDeck;
}

export async function deleteDeck(deckId: string) {
  await db.delete(decksTable)
    .where(eq(decksTable.id, deckId));
}
```

```typescript
// ✅ CORRECT - Using query helpers in Server Components
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function DecksPage() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  
  // Use query helper instead of direct DB calls
  const decks = await getUserDecks(userId);
    
  return <DecksList decks={decks} />;
}
```

```typescript
// ✅ CORRECT - Using query helpers in Server Actions
import { auth } from "@clerk/nextjs/server";
import { createDeck, getDeckWithCards } from "@/db/queries/deck-queries";
import { revalidatePath } from "next/cache";

export async function createDeckAction(input: CreateDeckInput) {
  const validatedData = CreateDeckSchema.parse(input);
  
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  // Use query helper instead of direct DB calls
  const newDeck = await createDeck({ ...validatedData, userId });
  
  revalidatePath("/decks");
  return newDeck;
}
```

```typescript
// ❌ FORBIDDEN - Direct database operations in pages/components
export default async function DecksPage() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  
  // ❌ DON'T perform direct DB operations
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
    
  return <DecksList decks={decks} />;
}
```

```typescript
// ❌ FORBIDDEN - Direct database operations in Server Actions
export async function createDeckAction(input: CreateDeckInput) {
  // ❌ DON'T perform direct DB operations
  const newDeck: NewDeck = { ...validatedData, userId };
  await db.insert(decksTable).values(newDeck);
  
  revalidatePath("/decks");
}
```

#### Required Query File Structure
```
src/
└── db/
    ├── index.ts           # Database connection
    ├── schema.ts          # Drizzle schema definitions
    └── queries/           # Query helper functions
        ├── deck-queries.ts    # All deck-related operations
        ├── card-queries.ts    # All card-related operations
```

#### Query Helper Guidelines
- **One file per entity** (decks, cards)
- **Export specific functions** for each operation (get, create, update, delete)
- **Include ownership validation** within query helpers when applicable
- **Return typed results** using schema types
- **Handle edge cases** (not found, etc.) within helpers
- **Use transactions** for multi-table operations
- **Keep queries focused** - one responsibility per function

### 2. Authentication: Redirect to Home Page
ALL protected pages MUST check authentication and redirect unauthenticated users to the home page (`/`):

```typescript
// ✅ CORRECT - Authentication check with home page redirect
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export default async function ProtectedPage() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  
  // Protected page content
  return <div>Protected content for user: {userId}</div>;
}
```

```typescript
// ❌ FORBIDDEN - No authentication check
export default async function ProtectedPage() {
  // ❌ Missing authentication check
  return <div>Unprotected content</div>;
}
```

```typescript
// ❌ FORBIDDEN - Redirect to sign-in page
export default async function ProtectedPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in"); // ❌ Don't redirect to sign-in
  
  return <div>Content</div>;
}
```

### 3. Data Retrieval: Server Components Only
ALL data fetching MUST be performed in Server Components, never in Client Components:

```typescript
// ✅ CORRECT - Server Component data fetching with query helpers
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function DecksPage() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  
  // Data fetching using query helper
  const decks = await getUserDecks(userId);
    
  return <DecksList decks={decks} />;
}
```

```typescript
// ❌ FORBIDDEN - Client Component data fetching
"use client";
import { useEffect, useState } from "react";

export function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // ❌ DON'T fetch data in Client Components
    fetch("/api/decks").then(res => res.json()).then(setDecks);
  }, []);
  
  return <DecksList decks={decks} />;
}
```

### 4. Data Mutations: Server Actions Only
ALL create, update, delete operations MUST use Server Actions:

```typescript
// ✅ CORRECT - Server Action for mutations using query helpers
import { auth } from "@clerk/nextjs/server";
import { createDeck, updateDeck, getDeckByIdAndUser } from "@/db/queries/deck-queries";
import { revalidatePath } from "next/cache";

export async function createDeckAction(data: NewDeck) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const newDeck: NewDeck = { ...data, userId };
  await createDeck(newDeck);
  
  revalidatePath("/decks");
}

export async function updateDeckAction(deckId: string, data: Partial<Deck>) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  // Verify ownership using query helper
  const existingDeck = await getDeckByIdAndUser(deckId, userId);
  if (!existingDeck) throw new Error("Deck not found");
  
  await updateDeck(deckId, data);
  revalidatePath("/decks");
}
```

```typescript
// ❌ FORBIDDEN - API route mutations
export async function POST(request: Request) {
  // ❌ DON'T use API routes for data mutations
  const body = await request.json();
  // mutation logic...
}
```

### 5. Data Validation: Zod Required
ALL data passed to Server Actions MUST be validated with Zod schemas:

```typescript
// ✅ CORRECT - Zod validation with TypeScript types
import { z } from "zod";

// Define Zod schema
const CreateDeckSchema = z.object({
  name: z.string().min(1, "Name is required").max(100),
  description: z.string().max(500).optional(),
});

// Extract TypeScript type from schema
type CreateDeckInput = z.infer<typeof CreateDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  // Validate input data
  const validatedData = CreateDeckSchema.parse(input);
  
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const newDeck: NewDeck = { ...validatedData, userId };
  await db.insert(decksTable).values(newDeck);
  
  revalidatePath("/decks");
}
```

```typescript
// ❌ FORBIDDEN - No validation or FormData usage
export async function createDeck(formData: FormData) {
  // ❌ DON'T use FormData as parameter type
  // ❌ DON'T skip validation
  const name = formData.get("name") as string;
  // direct usage without validation...
}

export async function createDeck(data: any) {
  // ❌ DON'T use 'any' type
  // ❌ DON'T skip validation
}
```

### 6. Form Handling Pattern
Use this pattern for forms with Server Actions:

```typescript
// Schema definition
const CreateCardSchema = z.object({
  front: z.string().min(1, "Front text is required"),
  back: z.string().min(1, "Back text is required"),
  deckId: z.string().uuid("Invalid deck ID"),
});

type CreateCardInput = z.infer<typeof CreateCardSchema>;

// Server Action
export async function createCard(input: CreateCardInput) {
  const validatedData = CreateCardSchema.parse(input);
  
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  // Verify deck ownership
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(eq(decksTable.id, validatedData.deckId), eq(decksTable.userId, userId)));
    
  if (!deck) throw new Error("Deck not found");
  
  const newCard: NewCard = validatedData;
  await db.insert(cardsTable).values(newCard);
  
  revalidatePath(`/decks/${validatedData.deckId}`);
}

// Client Component form
"use client";
import { createCard } from "./actions";

export function CreateCardForm({ deckId }: { deckId: string }) {
  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    
    const formData = new FormData(event.currentTarget);
    const input: CreateCardInput = {
      front: formData.get("front") as string,
      back: formData.get("back") as string,
      deckId,
    };
    
    try {
      await createCard(input);
      // Handle success
    } catch (error) {
      // Handle validation/server errors
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="front" placeholder="Front" />
      <input name="back" placeholder="Back" />
      <button type="submit">Create Card</button>
    </form>
  );
}
```

## Required Patterns

### Server Action File Structure
```typescript
// actions/deck-actions.ts
"use server";

import { z } from "zod";
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable, type NewDeck } from "@/db/schema";
import { revalidatePath } from "next/cache";

// 1. Define Zod schemas
const CreateDeckSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
});

const UpdateDeckSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional(),
});

// 2. Extract TypeScript types
type CreateDeckInput = z.infer<typeof CreateDeckSchema>;
type UpdateDeckInput = z.infer<typeof UpdateDeckSchema>;

// 3. Implement Server Actions
export async function createDeck(input: CreateDeckInput) {
  const validatedData = CreateDeckSchema.parse(input);
  // Implementation...
}

export async function updateDeck(input: UpdateDeckInput) {
  const validatedData = UpdateDeckSchema.parse(input);
  // Implementation...
}
```

### Error Handling
```typescript
export async function createDeck(input: CreateDeckInput) {
  try {
    const validatedData = CreateDeckSchema.parse(input);
    // Server Action logic...
    return { success: true };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, errors: error.errors };
    }
    return { success: false, error: "Failed to create deck" };
  }
}
```

## Forbidden Patterns

❌ **Direct database operations outside query helpers**:
```typescript
// DON'T perform direct Drizzle queries in pages/components
// DON'T perform direct Drizzle queries in Server Actions
// DON'T bypass the db/queries abstraction layer
```

❌ **Client-side data fetching**:
```typescript
// DON'T use useEffect for data fetching
// DON'T use fetch() in Client Components
// DON'T use SWR/React Query for initial data
```

❌ **API routes for mutations**:
```typescript
// DON'T create POST/PUT/DELETE API routes
// DON'T use fetch() for mutations from Client Components
```

❌ **Unvalidated data**:
```typescript
// DON'T skip Zod validation
// DON'T use FormData as Server Action parameter type
// DON'T use 'any' types for data
```

❌ **Missing revalidation**:
```typescript
// DON'T forget revalidatePath() after mutations
// DON'T use router.refresh() in Client Components
```

## Best Practices

1. **Always use query helpers** from `db/queries` directory for all data operations
2. **Organize query helpers** by entity (one file per table/domain)
3. **Always check authentication** first in protected pages and redirect to home page (`/`) if not authenticated
4. **Co-locate Server Actions** with the components that use them
5. **Use revalidatePath()** after all mutations to update cached data
6. **Handle validation errors** gracefully in Client Components
7. **Use TypeScript types** derived from Zod schemas (`z.infer<>`)
8. **Verify user ownership** within query helpers when applicable
9. **Use transactions** for multi-table operations within query helpers
10. **Return structured results** from Server Actions for error handling
11. **Keep query functions focused** - one responsibility per function
12. **Include error handling** within query helpers for edge cases

## Migration from Client-side Patterns

When refactoring existing code:

1. **Create query helpers** in `db/queries` directory for all data operations
2. **Replace direct database calls** with query helper functions
3. **Move data fetching** from `useEffect` to Server Components
4. **Convert API routes** to Server Actions for mutations
5. **Add Zod validation** to all data inputs
6. **Replace FormData** parameters with typed objects
7. **Add revalidatePath()** calls after mutations
8. **Update error handling** to work with Server Action patterns
9. **Organize query helpers** by entity with focused responsibilities

Remember: **All data operations must use query helpers with proper validation and type safety.**
